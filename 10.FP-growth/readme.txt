使用fpgrowth算法来挖掘几十万条数据的频繁项集。
最后返回的结果和书上一致

思路整理：
首先扫描一遍数据集，挖掘数据集的频繁项集
然后在扫描一遍数据集，每条数据集以频繁项集来排序，以空集为顶点，每遇到一条数据就向下延展，延展过程中在节点处记录此节点的次数。这样就建立好了fp树，返回头结点和表头
然后从表头的每个元素开始循环，对每个元素选取前缀路径并生成fp树和它的表头，这是它的条件fp树，然后进行迭代，迭代的过程中保存表头，这样可以通过表头来抓取频繁集
最后输出所有频繁项集

写代码时觉察到的决策树算法的缺点和改进点：
1.注意点：怎么利用头指针表来给每条数据排序，各个指针是怎么指向的，怎么从fp树中得到频繁集的
2.排序的作用是能直接剪去非频繁集。用前缀路劲的原始是使生成的频繁集不重复。
3.书上的fpgrowth算法虽然说不能挖掘关联规则，但是貌似能够返回频繁集的数量，从而得到频繁集的支持度，从而得到可信度，从而可以挖掘关联规则？问题在于是否能完全返回频繁集的数量？看完本书总结的时候考虑

学到的python代码：
1.sorted(a.items(), key=lambda x:x[1], reverse = False )对字典的值进行排序，输出列表
sorted(a.items(), key=lambda x:x[0], reverse = False )对字典的键进行排序，输出别表
字典不能进行排序，只能输出一个字典的元素组成的列表
2.使用类来建造树
3，有时候用while会比直接递归函数好很多
4.reverse方法返回空值
5。frozenset({'1', '11'})和frozenset({'11', '1'})是相等的
6、当初始化一个空的set元素时，用这个：set([])





